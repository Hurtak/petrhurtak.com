(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[409],{702:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/articles/union-types",function(){return t(9184)}])},6482:function(e,n,t){"use strict";t.d(n,{Br:function(){return a.Br},EK:function(){return a.EK},Ee:function(){return a.Ee},H1:function(){return a.H1},H2:function(){return a.H2},HO:function(){return a.HO},Li:function(){return a.Li},P:function(){return a.P},S0:function(){return a.S0},Tc:function(){return a.Tc},Tr:function(){return a.Tr},Tx:function(){return a.Tx},_P:function(){return a._P},aV:function(){return a.aV},cK:function(){return a.cK},iA:function(){return a.iA},nk:function(){return a.nk},pu:function(){return a.pu},rU:function(){return a.rU},z1:function(){return a.z1}});var a=t(9465)},7776:function(e,n,t){"use strict";t.d(n,{x:function(){return m}});var a=t(5893),r=t(645),i=t.n(r),s=t(9008),c=t.n(s),o=t(8422),l=t(7001),d=t(191),u=t(4047);let p=()=>(0,a.jsx)(a.Fragment,{children:"\xb7"});var h=t(9829);let y=e=>e.format("YYYY-MMM-DD"),f=e=>{let{articleBlog:n,articleComponent:t}=e,r=l.h.utc(n.datePublication),s=n.dateLastUpdate?l.h.utc(n.dateLastUpdate):void 0;return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(u.$,{title:n.title}),(0,a.jsx)(c(),{children:(0,a.jsx)("meta",{name:"description",content:n.description,className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]])})}),(0,a.jsxs)("article",{className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]]),children:[(0,a.jsx)("h1",{className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]]),children:n.title}),(0,a.jsx)("p",{className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]])+" time-wrapper",children:s?(0,a.jsxs)(a.Fragment,{children:["Published"," ",(0,a.jsx)("time",{title:"Publication date",dateTime:r.toISOString(),className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]]),children:y(r)}),(0,a.jsx)("br",{className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]])}),"Updated:"," ",(0,a.jsx)("time",{title:"Last update date",dateTime:s.toISOString(),className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]]),children:y(s)})]}):(0,a.jsx)("time",{title:"Publication date",dateTime:r.toISOString(),className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]]),children:y(r)})}),(0,a.jsx)("div",{className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]])+" article-content",children:(0,a.jsx)(t,{className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]])})})]}),(0,a.jsxs)("p",{className:i().dynamic([["9afce2f4c51a17ad",[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)]]])+" links",children:[(0,a.jsx)(h.r,{href:o._j.articleGitHubLink(n.articleDirectory),children:"Edit on GitHub"})," ",(0,a.jsx)(p,{})," ",(0,a.jsx)(h.r,{href:o._j.articleXSearch(n.slug),children:"Discuss on X"})," "]}),(0,a.jsx)(i(),{id:"9afce2f4c51a17ad",dynamic:[(0,d.LH)(.5),(0,d.LH)(5),(0,d.LH)(2),(0,d.LH)(3)],children:"h1.__jsx-style-dynamic-selector{margin:0}.time-wrapper.__jsx-style-dynamic-selector{margin:0}time.__jsx-style-dynamic-selector{display:inline-block;padding-top:".concat((0,d.LH)(.5),"}.article-content.__jsx-style-dynamic-selector{padding-top:").concat((0,d.LH)(5),"}.article-content.__jsx-style-dynamic-selector>*{margin:").concat((0,d.LH)(2)," 0}.article-content.__jsx-style-dynamic-selector>*:first-child{margin-top:0}.article-content.__jsx-style-dynamic-selector>*:last-child{margin-bottom:0}.links.__jsx-style-dynamic-selector{margin:0;margin-top:").concat((0,d.LH)(3),"}")})]})},m=e=>n=>{let{articleBlog:t}=n;return(0,a.jsx)(f,{articleBlog:t,articleComponent:e})}},9184:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return s},default:function(){return c}});var a=t(5893),r=t(6482),i=t(7776),s=!0,c=(0,i.x)(()=>(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(r.P,{children:["Discriminate union types (also called ",(0,a.jsx)(r.Tx,{children:"tagged unions"})," or ",(0,a.jsx)(r.Tx,{children:"algebraic data types"}),") are one of my favorite features of any typed language."]}),(0,a.jsx)(r.P,{children:"They can be used to cleanly model and describe state transitions in your business logic and your UI. They are worth knowing about because patterns emerging from these can also be used in dynamic languages without the need for a type system."}),(0,a.jsx)(r.H1,{children:"HTTP request example"}),(0,a.jsx)(r.P,{children:"Let's take a simple example of making an HTTP request and displaying the response in the UI. With these async operations you also need to handle the loading and error case and display it to the user."}),(0,a.jsx)(r.H1,{children:'"Traditional" approach'}),(0,a.jsx)(r.EK,{language:"jsx",children:"\n      // Initial state\n      let apiData = null;\n\n      // User initiates API request, data is loading\n      apiData = {\n        error: false,\n        loading: true,\n        data: null\n      };\n\n      try {\n        const requestData = await getApiData();\n\n        // Data is fetched\n        apiData = {\n          error: false,\n          loading: false,\n          data: requestData\n        };\n      } catch (error) {\n        // Error with the request\n        apiData = {\n          error: error,\n          loading: false,\n          data: null\n        };\n      }\n\n      // Somewhere in your UI code\n      if (!apiData) {\n        return <p>Initial state</p>;\n      } else if (apiData.loading) {\n        return <p>Loading</p>;\n      } else if (apiData.error) {\n        return <p>Error</p>;\n      }\n\n      return <p>Api data: {apiData.data}</p>;\n    "}),(0,a.jsx)(r.P,{children:"This is an approach that can be often seen. While it might be ok when the structure is small and local, problems will start surfacing when there will be more state transitions or when the data structure will be used in more places."}),(0,a.jsx)(r.H2,{children:"Problems"}),(0,a.jsxs)(r.aV,{children:[(0,a.jsx)(r.Li,{children:"Instead of a clear indication of which type of state we are in, there are a bunch of boolean flags or empty/non-empty data values and we need to decide which has higher priority and what combination of these fields results in the corresponding state type."}),(0,a.jsxs)(r.Li,{children:["The data structure can end up in states that do not make sense, like ",(0,a.jsx)(r.EK,{children:"loading: true"})," and"," ",(0,a.jsx)(r.EK,{children:"error: true"})," at the same time."]}),(0,a.jsxs)(r.Li,{children:["Extending the structure, let's say by adding ",(0,a.jsx)(r.EK,{children:"RETRYING"})," or ",(0,a.jsx)(r.EK,{children:"CANCELLED"})," request states, only magnifies the problem."]})]}),(0,a.jsx)(r.H1,{children:"Discriminated union types"}),(0,a.jsx)(r.P,{children:"Let's see how we would model this problem when using union types. The best part is you do not even need typed language to take advantage of this approach."}),(0,a.jsx)(r.EK,{language:"jsx",children:'\n      // Initial state\n      let apiData = {\n        type: "INITIAL"\n      };\n\n      // User initiates API request, data is loading\n      apiData = {\n        type: "LOADING"\n      };\n\n      try {\n        const requestData = await getApiData();\n\n        // Data is fetched\n        apiData = {\n          type: "FINISHED",\n          data: requestData\n        };\n      } catch (error) {\n        // Error with the request\n        apiData = {\n          type: "ERROR",\n          error: error\n        };\n      }\n\n      // Somewhere in your UI code\n      switch (apiData.type) {\n        case "INITIAL":\n          return <p>Initial state</p>;\n        case "LOADING":\n          return <p>Loading</p>;\n        case "ERROR":\n          return <p>Error</p>;\n        case "FINISHED":\n          return <p>Api data: {apiData.data}</p>;\n        default:\n          throw new Error(`Unknown apiData.type "${apiData.type}"`);\n      }\n    '}),(0,a.jsx)(r.P,{children:"This is much better now because we have a clear indicator of what state transition we are in, and we do not need to check boolean flags that can be mutually exclusive. Also the current state we are in only has data relevant to it, so for example, when we are in the loading state there is no empty data field and false in the error field."}),(0,a.jsx)(r.H1,{children:"TypeScript"}),(0,a.jsx)(r.P,{children:"If you have typed language that supports union types you can take advantage of the type system to enforce these rules during compile time. Here is how it would look like in TypeScript."}),(0,a.jsx)(r.EK,{language:"ts",children:'\n      type HttpData<T> =\n        | { type: "INITIAL" }\n        | { type: "LOADING" }\n        | { type: "ERROR"; error: any }\n        | { type: "FINISHED"; data: T };\n    '}),(0,a.jsxs)(r.P,{children:["This uses another interesting feature of TypeScript that is"," ",(0,a.jsx)(r.rU,{href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types",children:"literal types"}),", meaning you can have a type of exact values, like ",(0,a.jsx)(r.EK,{children:'"INITIAL"'}),", instead of super-set like"," ",(0,a.jsx)(r.EK,{children:"string"}),"."]}),(0,a.jsx)(r.EK,{language:"tsx",children:'\n      type HttpData<T> =\n        | { type: "INITIAL" }\n        | { type: "LOADING" }\n        | { type: "ERROR"; error: any }\n        | { type: "FINISHED"; data: T };\n\n      const apiData: HttpData<string> = {\n        type: "FINISHED",\n        data: "api response data"\n      };\n\n      // Somewhere in your UI code\n      switch (apiData.type) {\n        case "INITIAL":\n          return <p>Initial state</p>;\n        case "LOADING":\n          return <p>Loading</p>;\n        case "ERROR":\n          return <p>Error</p>;\n        case "FINISHED":\n          return <p>Api data: {apiData.data}</p>;\n        default:\n          throw new Error(`Unknown apiData.type "${apiData.type}"`);\n      }\n    '})]}))}},function(e){e.O(0,[163,733,888,774,179],function(){return e(e.s=702)}),_N_E=e.O()}]);